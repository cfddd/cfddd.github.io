const e=JSON.parse('{"key":"v-a73b7ee6","path":"/Algorithm/contents/B.GregandGraph.html","title":"B. Greg and Graph","lang":"zh-CN","frontmatter":{"title":"B. Greg and Graph","icon":"calculator","description":"题目 B. Greg and Graph 题意 输入 n(1≤n≤500) 表示 n 个点的有向完全图，然后输入 n*n 的邻接矩阵 a，其中 a[i][j] 表示 i 到 j 的边权，范围 [1,1e5]（特例是 a[i][i]=0）。 图的节点编号从 1 开始。 然后输入 1~n 的排列，表示我要一个个地删除图上的点，每删除一个点，这个点的出边和入边都会被删除。 输出 n 个数，第 i 个数表示第 i 次删除之前，所有剩余点对的最短路之和。","head":[["meta",{"property":"og:url","content":"https://cfddd.github.io/Algorithm/contents/B.GregandGraph.html"}],["meta",{"property":"og:site_name","content":"俄罗斯刺沙蓬"}],["meta",{"property":"og:title","content":"B. Greg and Graph"}],["meta",{"property":"og:description","content":"题目 B. Greg and Graph 题意 输入 n(1≤n≤500) 表示 n 个点的有向完全图，然后输入 n*n 的邻接矩阵 a，其中 a[i][j] 表示 i 到 j 的边权，范围 [1,1e5]（特例是 a[i][i]=0）。 图的节点编号从 1 开始。 然后输入 1~n 的排列，表示我要一个个地删除图上的点，每删除一个点，这个点的出边和入边都会被删除。 输出 n 个数，第 i 个数表示第 i 次删除之前，所有剩余点对的最短路之和。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-05T07:04:01.000Z"}],["meta",{"property":"article:author","content":"俄罗斯刺沙蓬"}],["meta",{"property":"article:modified_time","content":"2023-07-05T07:04:01.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"B. Greg and Graph\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-05T07:04:01.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"俄罗斯刺沙蓬\\",\\"url\\":\\"https://cfddd.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"题目","slug":"题目","link":"#题目","children":[]},{"level":2,"title":"题意","slug":"题意","link":"#题意","children":[]},{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]}],"git":{"createdTime":1688540641000,"updatedTime":1688540641000,"contributors":[{"name":"cfd","email":"2909047212@qq.com","commits":1}]},"readingTime":{"minutes":1.14,"words":341},"filePathRelative":"Algorithm/contents/B.GregandGraph.md","localizedDate":"2023年7月5日","excerpt":"<h2> 题目</h2>\\n<ul>\\n<li><a href=\\"https://codeforces.com/contest/295/problem/B\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">B. Greg and Graph</a></li>\\n</ul>\\n<h2> 题意</h2>\\n<ul>\\n<li>输入 n(1≤n≤500) 表示 n 个点的有向完全图，然后输入 n*n 的邻接矩阵 a，其中 a[i][j] 表示 i 到 j 的边权，范围 [1,1e5]（特例是 a[i][i]=0）。</li>\\n<li>图的节点编号从 1 开始。</li>\\n<li>然后输入 1~n 的排列，表示我要一个个地删除图上的点，每删除一个点，这个点的出边和入边都会被删除。</li>\\n<li>输出 n 个数，第 i 个数表示第 i 次删除之前，所有剩余点对的最短路之和。</li>\\n</ul>","autoDesc":true}');export{e as data};

import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r,o as n,c as h,a as e,b as a,d as t,f as d}from"./app-833b555e.js";const o={},s=e("h1",{id:"虚拟存储器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#虚拟存储器","aria-hidden":"true"},"#"),a(" 虚拟存储器")],-1),p={href:"https://zhuanlan.zhihu.com/p/391327282",target:"_blank",rel:"noopener noreferrer"},c=d('<h2 id="页面置换算法" tabindex="-1"><a class="header-anchor" href="#页面置换算法" aria-hidden="true">#</a> 页面置换算法</h2><p>当需要调入新页面，但内存已满时，页面置换算法 选择一个被换出的页面，再将新页面载入</p><h4 id="先进先出算法" tabindex="-1"><a class="header-anchor" href="#先进先出算法" aria-hidden="true">#</a> 先进先出算法</h4><h4 id="opt页面置换算法" tabindex="-1"><a class="header-anchor" href="#opt页面置换算法" aria-hidden="true">#</a> OPT页面置换算法</h4><p>最佳算法（OPTimal）：选择未来最久不被访问的</p><p>不可能实现！（预测未来最热卖的商品）</p><p>意义：给出理论上的最好结果，以供比较</p><h4 id="最近最久未使用-least-recently-used-lru" tabindex="-1"><a class="header-anchor" href="#最近最久未使用-least-recently-used-lru" aria-hidden="true">#</a> 最近最久未使用（Least Recently Used）LRU</h4><p>选择自上次被访问以来经历时间最久的</p><p>硬件开销太大，难以实现</p><p>实际OS中，采用近似LRU的方法</p><h4 id="clock算法" tabindex="-1"><a class="header-anchor" href="#clock算法" aria-hidden="true">#</a> Clock算法</h4><p>循环队列，依次检查。若A（访问位）=0，换出；若A=1，置A=0，检查下一个。</p><p>改进后</p><p>不仅利用访问位A，还利用修改位D</p><ul><li>A=0，D=0，最近未访问，也未被修改；</li><li>A=0，D=1，最近未访问，但被修改；</li><li>A=1，D=0，最近被访问，但未被修改；</li><li>A=1，D=1，最近被访问，且被修改。</li></ul><p>AD=00最应该被替换，AD=11最不应替换</p><h2 id="页面分配策略" tabindex="-1"><a class="header-anchor" href="#页面分配策略" aria-hidden="true">#</a> 页面分配策略</h2><p>给每个进程分配至少多少个物理块</p><h4 id="固定分配和可变分配" tabindex="-1"><a class="header-anchor" href="#固定分配和可变分配" aria-hidden="true">#</a> 固定分配和可变分配</h4><p>给每个进程分配多少个物理块？</p><p><strong>固定</strong></p><ul><li>平均分配算法</li><li>比例分配算法</li><li>优先级分配算法</li></ul><p><strong>可变</strong></p><p>允许分配给进程的物理块数随时间变化</p><h4 id="全局-局部置换" tabindex="-1"><a class="header-anchor" href="#全局-局部置换" aria-hidden="true">#</a> 全局&amp;局部置换</h4><p>可变分配在置换时，换出属于谁的页面？</p><p>若每个进程已经<strong>固定分配</strong>物理页面数量，则不可能去抢夺其它进程的页面，因而也就不可能<strong>全局置换</strong>。</p><p><strong>全局置换（Global Replacement）</strong></p><ul><li>可以置换所有进程的页面</li></ul><p><strong>局部置换（Local Replacement）</strong></p><ul><li>仅置换进程自己的页面</li></ul><h2 id="页面缓冲算法" tabindex="-1"><a class="header-anchor" href="#页面缓冲算法" aria-hidden="true">#</a> 页面缓冲算法</h2><p>页缓冲算法（PBA，Page Buffering Algorithm）</p><ul><li>空闲页面池，统一管理空闲的物理页面</li><li>修改页面池，将D=1的页面暂存</li></ul><p>好处：防止将被换出的页面马上又要使用的情况（house keeping）</p><h2 id="实用策略-工作集" tabindex="-1"><a class="header-anchor" href="#实用策略-工作集" aria-hidden="true">#</a> 实用策略-工作集</h2><ul><li>进程开始执行后，随着访问新页面逐步建立较稳定的工作集</li><li>当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</li><li>局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</li></ul><h2 id="抖动" tabindex="-1"><a class="header-anchor" href="#抖动" aria-hidden="true">#</a> 抖动</h2><ul><li>CPU利用率与并发进程数存在相互促进和制约的关系 <ul><li>进程数少时，提高并发进程数，可提高CPU利用率</li><li>并发进程进一步增加，导致内存访问增加</li><li>分配给每个进程的物理块太少，导致缺页率上升和CPU利用下降</li><li>抖动：每个进程频繁的缺页，换进/换出</li></ul></li><li>抖动 <ul><li>进程物理页面太少，不能包含工作集</li><li>造成大量缺页，频繁置换</li><li>进程运行速度变慢</li></ul></li><li>产生抖动的原因 <ul><li>随着驻留内存的进程数目增加，分配给每个进程的物理页面数</li><li>不断减小，缺页率不断上升</li></ul></li><li>抖动的预防方法 <ul><li>采用局部置换策略</li><li>把工作集算法融入处理机调度</li><li>“L=S”准则</li><li>选择暂停的进</li></ul></li></ul>',40);function u(f,_){const l=r("ExternalLinkIcon");return n(),h("div",null,[s,e("p",null,[e("a",p,[a("https://zhuanlan.zhihu.com/p/391327282"),t(l)])]),c])}const m=i(o,[["render",u],["__file","27.html.vue"]]);export{m as default};

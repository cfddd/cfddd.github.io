import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as d,c as h,a,b as e,d as r,f as l}from"./app-f94c3d64.js";const o={},s=l('<h1 id="什么是图" tabindex="-1"><a class="header-anchor" href="#什么是图" aria-hidden="true">#</a> 什么是图？</h1><figure><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417193318095-139030009.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="把图在计算机中表示-储存" tabindex="-1"><a class="header-anchor" href="#把图在计算机中表示-储存" aria-hidden="true">#</a> 把图在计算机中表示（储存）</h1><figure><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417193829192-2101680249.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h1 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序" aria-hidden="true">#</a> 拓扑排序</h1><h2 id="度" tabindex="-1"><a class="header-anchor" href="#度" aria-hidden="true">#</a> 度</h2><ul><li>与一个顶点 v 关联的边的条数称作该顶点的 度 (degree)</li><li>在有向图 G = (V, E) 中，以一个顶点 v 为起点的边的条数称为该顶点的 出度 (out-degree)，</li><li>以一个顶点 v 为终点的边的条数称为该节点的 入度 (in-degree)</li></ul><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路</h2><ul><li><p>首先记录各个点的入度</p></li><li><p>然后将入度为 0 的点放入队列</p></li><li><p>将队列里的点依次出队列，然后找出所有出队列这个点发出的边，删除边，同事边的另一侧的点的入度 -1。</p></li><li><p>如果所有点都进过队列，则可以拓扑排序，输出所有顶点。否则输出-1，代表不可以进行拓扑排序。</p></li></ul><h2 id="参考代码" tabindex="-1"><a class="header-anchor" href="#参考代码" aria-hidden="true">#</a> 参考代码</h2><figure><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417194634702-1241220534.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="应用" tabindex="-1"><a class="header-anchor" href="#应用" aria-hidden="true">#</a> 应用</h2><p>判断图中是否有环路</p><h2 id="练习" tabindex="-1"><a class="header-anchor" href="#练习" aria-hidden="true">#</a> 练习</h2>',14),c={href:"https://www.luogu.com.cn/problem/P1347",target:"_blank",rel:"noopener noreferrer"},f=l('<h1 id="最短路算法" tabindex="-1"><a class="header-anchor" href="#最短路算法" aria-hidden="true">#</a> 最短路算法</h1><h2 id="dijkstra单源最短路算法和堆优化" tabindex="-1"><a class="header-anchor" href="#dijkstra单源最短路算法和堆优化" aria-hidden="true">#</a> dijkstra单源最短路算法和堆优化</h2><h3 id="思路-1" tabindex="-1"><a class="header-anchor" href="#思路-1" aria-hidden="true">#</a> 思路</h3><ul><li><p>核心思想是利用贪心策略，从源点开始，逐步向外扩展最短路径，直到扩展到目标点为止。</p></li><li><p>Dijkstra算法维护当前已知的最短路径和距离源点最近的节点，然后根据贪心策略选择最优节点进行扩展。</p></li><li><p>初始化dist数组，将源点到其他各个顶点的距离全部设为无穷大。将源点标记为已确定最短距离的顶点。</p></li><li><p>遍历与源点相邻的所有顶点，更新它们的距离，即若源点到该相邻顶点的距离小于目前dist数组中保存的距离，则将该距离更新为更小的值。</p></li><li><p>从尚未确定最短距离的顶点中选择一个与源点距离最小的顶点，将其标记为已确定最短距离的顶点，并继续遍历其相邻顶点。</p></li><li><p>重复上面两个步骤，直到所有顶点的最短距离都已被确定。</p></li></ul>',4),p={id:"dijkstra",tabindex:"-1"},g=a("a",{class:"header-anchor",href:"#dijkstra","aria-hidden":"true"},"#",-1),u={href:"https://mp.weixin.qq.com/s/Rdhhi0BENgtWCKKxMZm4Ew",target:"_blank",rel:"noopener noreferrer"},b=a("h3",{id:"练习-1",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#练习-1","aria-hidden":"true"},"#"),e(" 练习")],-1),m={href:"https://www.acwing.com/problem/content/4243/",target:"_blank",rel:"noopener noreferrer"},_=l('<h2 id="bellman-ford-算法和spfa优化" tabindex="-1"><a class="header-anchor" href="#bellman-ford-算法和spfa优化" aria-hidden="true">#</a> bellman-ford 算法和SPFA优化</h2><ul><li>bellman-ford 算法的松弛操作</li><li>枚举所有边，松弛所有点到原点的距离</li><li>跑正常的有最短路的图没问题（最短路径存在，并且显然不超过点的数量-1）</li><li>但存在负环时，可以知道途中不存在最短路，因为每次松弛都会把最短路变得越来越小，没有意义</li><li>一般来说，一个图存在负环，就不可能有最短路，所以用处不多，最多用来判断是否存在负环</li><li>spfa只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。<br><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417204931211-2111133644.png" alt="" loading="lazy"></li></ul><h2 id="folyd-多源最短路" tabindex="-1"><a class="header-anchor" href="#folyd-多源最短路" aria-hidden="true">#</a> folyd 多源最短路</h2><p>借助中间点来设计最短路算法</p><ul><li>定义一个数组 f[k][x][y]，表示只允许经过结点 1 到 k，结点 x 到结点 y 的最短路长度。</li><li>f[0][x][y]：x 与 y 的边权，或者 0，或者 无穷</li><li>f[k][x][y] = min(f[k-1][x][y], f[k-1][x][k]+f[k-1][k][y])（f[k-1][x][y]，为不经过 k 点的最短路径，而 f[k-1][x][k]+f[k-1][k][y]，为经过了 k 点的最短路）。</li></ul><h2 id="核心代码" tabindex="-1"><a class="header-anchor" href="#核心代码" aria-hidden="true">#</a> 核心代码</h2><p><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417205417821-659429971.png" alt="" loading="lazy"><br> 因为第一维对结果无影响，我们可以发现数组的第一维是可以省略的，于是可以直接改成 f[x][y] = min(f[x][y], f[x][k]+f[k][y])。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><h2 id="图的概念和表示方法" tabindex="-1"><a class="header-anchor" href="#图的概念和表示方法" aria-hidden="true">#</a> 图的概念和表示方法</h2><ul><li>G = (V，E) 意思是 Graph = (Vertices，Edges)，图 = （点集，边集）</li><li>图有无向图、有向图、混合图，有带权图、无权图……树是图的一种</li><li>图的表示的方法有：邻接矩阵、邻接表、链式向前星</li></ul><h2 id="拓扑排序-1" tabindex="-1"><a class="header-anchor" href="#拓扑排序-1" aria-hidden="true">#</a> 拓扑排序</h2><ul><li>理解度的含义</li><li>然后将入度为 0 的点放入队列，删边，更新度数，再次入队</li><li>可以用来找环路</li></ul><h2 id="最短路" tabindex="-1"><a class="header-anchor" href="#最短路" aria-hidden="true">#</a> 最短路</h2><p><img src="https://cdn.acwing.com/media/article/image/2019/12/13/1833_db6dffa81d-37ff39642fd8f74476ddcd99944d1b4.png" alt="" loading="lazy"><br><img src="https://img2023.cnblogs.com/blog/2740326/202304/2740326-20230417210305387-807470027.png" alt="" loading="lazy"></p><p>参考资料：</p>',15),x={href:"https://oi-wiki.org/",target:"_blank",rel:"noopener noreferrer"},k={href:"https://www.acwing.com/activity/content/11/",target:"_blank",rel:"noopener noreferrer"};function y(w,v){const i=t("ExternalLinkIcon");return d(),h("div",null,[s,a("p",null,[a("a",c,[e("luogu P1347排序"),r(i)])]),f,a("h3",p,[g,e(),a("a",u,[e("dijkstra"),r(i)])]),b,a("p",null,[a("a",m,[e("acwing 4240.青蛙"),r(i)])]),_,a("p",null,[a("a",x,[e("https://oi-wiki.org/"),r(i)])]),a("p",null,[a("a",k,[e("https://www.acwing.com/activity/content/11/"),r(i)])])])}const z=n(o,[["render",y],["__file","5_.html.vue"]]);export{z as default};

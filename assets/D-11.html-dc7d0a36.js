const t=JSON.parse(`{"key":"v-8d6efe52","path":"/Algorithm/D-11.html","title":"D - 11（逆元好题）","lang":"zh-CN","frontmatter":{"title":"D - 11（逆元好题）","icon":"calculator","description":"#include&lt;bits/stdc++.h&gt; #define debug1(a) cout&lt;&lt;#a&lt;&lt;'='&lt;&lt; a &lt;&lt; endl; #define debug2(a,b) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;endl; #define debug3(a,b,c) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;endl; #define debug4(a,b,c,d) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\" \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;endl; #define debug5(a,b,c,d,e) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\" \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;\\" \\"&lt;&lt;#e&lt;&lt;\\" = \\"&lt;&lt;e&lt;&lt;endl; #define debug0(x) cout &lt;&lt; \\"debug0: \\" &lt;&lt; x &lt;&lt; endl #define fr(t, i, n)for (long long i = t; i &lt; n; i++) #define YES cout&lt;&lt;\\"Yes\\"&lt;&lt;endl #define NO cout&lt;&lt;\\"No\\"&lt;&lt;endl #define fi first #define se second #define int long long using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;LL,LL&gt; PLL; //#pragma GCC optimize(3,\\"Ofast\\",\\"inline\\") //#pragma GCC optimize(2) /* 如果无视不同的要求，那么答案就是 C(n+1,k)。 什么时候会有重复的呢？ 只可能是 a 中那两个相同的数字，恰好选了其中一个导致的。 设 a 中那两个相同数字的下标分别为 p 和 q（下标从 0 开始）， 手玩一下可以发现，如果剩余的 k-1 个数是在 p 左边或 q 右边中选的，就会导致重复。 这一共有 m = p + (n-q) 个数��� 因此答案为 C(n+1,k) - C(m,k-1)。 计算组合数需要逆元。 逆元组合数，无时无刻都要注意逆元的定义 */ const int N = 100010,mod = 1e9 + 7; int fact[N],ifact[N]; int a[N]; int to[N]; LL qmi(int a,int b,int p){ //快速幂 LL res = 1; while(b){ if(b&amp;1)res = (LL)res * a % p; b = b &gt;&gt; 1; a = (LL)a * a % p; } return res; } LL C(int a,int b) { return (LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod; } void solve() { fact[0] = ifact[0] = 1; for(int i = 1;i &lt; N;i++){ fact[i] = (LL)fact[i - 1] * i % mod; //阶乘 ifact[i] = (LL)ifact[i - 1] * qmi(i, mod - 2, mod) % mod; //阶乘对于mod的乘法逆元 //cout &lt;&lt; fact[i] &lt;&lt; \\" \\" &lt;&lt; ifact[i] &lt;&lt; endl; } int n;cin &gt;&gt; n; for(int i = 1;i &lt;= n+1;i++)cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n+1;i++) { if(!to[a[i]])to[a[i]] = i; else { int l,r; l = to[a[i]],r=i; int m = l-1 + n - r + 1; //(LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod for(int i = 1;i &lt;= n+1;i ++) { if(m &gt;= i-1)cout &lt;&lt; (C(n+1,i) - C(m,i-1) + mod) % mod &lt;&lt; endl; else cout &lt;&lt; (C(n+1,i) % mod) &lt;&lt; endl; } break; } } } signed main() { /* ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); */ int T = 1;//cin &gt;&gt; T; while(T--){ solve(); } return 0; }","head":[["meta",{"property":"og:url","content":"https://cfddd.github.io/Algorithm/D-11.html"}],["meta",{"property":"og:site_name","content":"俄罗斯刺沙蓬"}],["meta",{"property":"og:title","content":"D - 11（逆元好题）"}],["meta",{"property":"og:description","content":"#include&lt;bits/stdc++.h&gt; #define debug1(a) cout&lt;&lt;#a&lt;&lt;'='&lt;&lt; a &lt;&lt; endl; #define debug2(a,b) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;endl; #define debug3(a,b,c) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;endl; #define debug4(a,b,c,d) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\" \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;endl; #define debug5(a,b,c,d,e) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\" \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\" \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\" \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;\\" \\"&lt;&lt;#e&lt;&lt;\\" = \\"&lt;&lt;e&lt;&lt;endl; #define debug0(x) cout &lt;&lt; \\"debug0: \\" &lt;&lt; x &lt;&lt; endl #define fr(t, i, n)for (long long i = t; i &lt; n; i++) #define YES cout&lt;&lt;\\"Yes\\"&lt;&lt;endl #define NO cout&lt;&lt;\\"No\\"&lt;&lt;endl #define fi first #define se second #define int long long using namespace std; typedef long long LL; typedef unsigned long long ULL; typedef pair&lt;int,int&gt; PII; typedef pair&lt;LL,LL&gt; PLL; //#pragma GCC optimize(3,\\"Ofast\\",\\"inline\\") //#pragma GCC optimize(2) /* 如果无视不同的要求，那么答案就是 C(n+1,k)。 什么时候会有重复的呢？ 只可能是 a 中那两个相同的数字，恰好选了其中一个导致的。 设 a 中那两个相同数字的下标分别为 p 和 q（下标从 0 开始）， 手玩一下可以发现，如果剩余的 k-1 个数是在 p 左边或 q 右边中选的，就会导致重复。 这一共有 m = p + (n-q) 个数��� 因此答案为 C(n+1,k) - C(m,k-1)。 计算组合数需要逆元。 逆元组合数，无时无刻都要注意逆元的定义 */ const int N = 100010,mod = 1e9 + 7; int fact[N],ifact[N]; int a[N]; int to[N]; LL qmi(int a,int b,int p){ //快速幂 LL res = 1; while(b){ if(b&amp;1)res = (LL)res * a % p; b = b &gt;&gt; 1; a = (LL)a * a % p; } return res; } LL C(int a,int b) { return (LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod; } void solve() { fact[0] = ifact[0] = 1; for(int i = 1;i &lt; N;i++){ fact[i] = (LL)fact[i - 1] * i % mod; //阶乘 ifact[i] = (LL)ifact[i - 1] * qmi(i, mod - 2, mod) % mod; //阶乘对于mod的乘法逆元 //cout &lt;&lt; fact[i] &lt;&lt; \\" \\" &lt;&lt; ifact[i] &lt;&lt; endl; } int n;cin &gt;&gt; n; for(int i = 1;i &lt;= n+1;i++)cin &gt;&gt; a[i]; for(int i = 1;i &lt;= n+1;i++) { if(!to[a[i]])to[a[i]] = i; else { int l,r; l = to[a[i]],r=i; int m = l-1 + n - r + 1; //(LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod for(int i = 1;i &lt;= n+1;i ++) { if(m &gt;= i-1)cout &lt;&lt; (C(n+1,i) - C(m,i-1) + mod) % mod &lt;&lt; endl; else cout &lt;&lt; (C(n+1,i) % mod) &lt;&lt; endl; } break; } } } signed main() { /* ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); */ int T = 1;//cin &gt;&gt; T; while(T--){ solve(); } return 0; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-03T12:00:26.000Z"}],["meta",{"property":"article:author","content":"俄罗斯刺沙蓬"}],["meta",{"property":"article:modified_time","content":"2023-07-03T12:00:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"D - 11（逆元好题）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-03T12:00:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"俄罗斯刺沙蓬\\",\\"url\\":\\"https://cfddd.github.io/\\"}]}"]]},"headers":[],"git":{"createdTime":1688385626000,"updatedTime":1688385626000,"contributors":[{"name":"cfd","email":"2909047212@qq.com","commits":1}]},"readingTime":{"minutes":1.86,"words":558},"filePathRelative":"Algorithm/D-11.md","localizedDate":"2023年7月3日","excerpt":"<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\"><pre class=\\"language-text\\"><code>#include&lt;bits/stdc++.h&gt;\\n#define debug1(a) cout&lt;&lt;#a&lt;&lt;'='&lt;&lt; a &lt;&lt; endl;\\n#define debug2(a,b) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\"  \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;endl;\\n#define debug3(a,b,c) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\"  \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\"  \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;endl;\\n#define debug4(a,b,c,d) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\"  \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\"  \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\"  \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;endl;\\n#define debug5(a,b,c,d,e) cout&lt;&lt;#a&lt;&lt;\\" = \\"&lt;&lt;a&lt;&lt;\\"  \\"&lt;&lt;#b&lt;&lt;\\" = \\"&lt;&lt;b&lt;&lt;\\"  \\"&lt;&lt;#c&lt;&lt;\\" = \\"&lt;&lt;c&lt;&lt;\\"  \\"&lt;&lt;#d&lt;&lt;\\" = \\"&lt;&lt;d&lt;&lt;\\"  \\"&lt;&lt;#e&lt;&lt;\\" = \\"&lt;&lt;e&lt;&lt;endl;\\n#define debug0(x) cout &lt;&lt; \\"debug0: \\" &lt;&lt; x &lt;&lt; endl\\n#define fr(t, i, n)for (long long i = t; i &lt; n; i++)\\n#define YES cout&lt;&lt;\\"Yes\\"&lt;&lt;endl\\n#define NO cout&lt;&lt;\\"No\\"&lt;&lt;endl\\n#define fi first\\n#define se second\\n#define int long long\\nusing namespace std;\\n\\ntypedef long long LL;\\ntypedef unsigned long long ULL;\\ntypedef pair&lt;int,int&gt; PII;\\ntypedef pair&lt;LL,LL&gt; PLL;\\n\\n//#pragma GCC optimize(3,\\"Ofast\\",\\"inline\\")\\n//#pragma GCC optimize(2)\\n\\n/*\\n\\n如果无视不同的要求，那么答案就是 C(n+1,k)。\\n什么时候会有重复的呢？\\n只可能是 a 中那两个相同的数字，恰好选了其中一个导致的。\\n设 a 中那两个相同数字的下标分别为 p 和 q（下标从 0 开始），\\n手玩一下可以发现，如果剩余的 k-1 个数是在 p 左边或 q 右边中选的，就会导致重复。\\n这一共有 m = p + (n-q) 个数���\\n因此答案为 C(n+1,k) - C(m,k-1)。\\n\\n计算组合数需要逆元。\\n\\n逆元组合数，无时无刻都要注意逆元的定义\\n*/\\n\\nconst int N = 100010,mod = 1e9 + 7;\\nint fact[N],ifact[N];\\nint a[N];\\nint to[N];\\nLL qmi(int a,int b,int p){                                          //快速幂\\n    LL res = 1;\\n    while(b){\\n        if(b&amp;1)res = (LL)res * a % p;\\n        b = b &gt;&gt; 1;\\n        a = (LL)a * a % p;\\n    }\\n    return res;\\n}\\nLL C(int a,int b)\\n{\\n    return (LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod;\\n}\\nvoid solve() \\n{\\n    fact[0] = ifact[0] = 1;\\n    \\n    for(int i = 1;i &lt; N;i++){\\n        fact[i] = (LL)fact[i - 1] * i % mod;                        //阶乘\\n        ifact[i] = (LL)ifact[i - 1] * qmi(i, mod - 2, mod) % mod;   //阶乘对于mod的乘法逆元\\n        //cout &lt;&lt; fact[i] &lt;&lt; \\" \\" &lt;&lt; ifact[i] &lt;&lt; endl;\\n    }\\n\\n    int n;cin &gt;&gt; n;\\n    for(int i = 1;i &lt;= n+1;i++)cin &gt;&gt; a[i];\\n\\n    \\n    for(int i = 1;i &lt;= n+1;i++)\\n    {\\n        if(!to[a[i]])to[a[i]] = i;\\n        else \\n        {\\n            int l,r;\\n            l = to[a[i]],r=i;\\n            int m = l-1 + n - r + 1;\\n            \\n    \\n            //(LL)fact[a] * ifact[b] % mod * ifact[a - b] % mod\\n            for(int i = 1;i &lt;= n+1;i ++)\\n            {\\n                if(m &gt;= i-1)cout &lt;&lt; (C(n+1,i) - C(m,i-1) + mod) % mod &lt;&lt; endl;\\n                else cout &lt;&lt; (C(n+1,i) % mod) &lt;&lt; endl;\\n            }\\n            break;\\n        }\\n    }\\n\\n}\\n\\nsigned main()\\n{\\n    /*\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    cout.tie(0);\\n    */\\n\\n    int T = 1;//cin &gt;&gt; T;\\n    while(T--){\\n        solve();\\n    }\\n    return 0;\\n}\\n\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{t as data};

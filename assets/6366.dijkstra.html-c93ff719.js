const s=JSON.parse('{"key":"v-ee0227ea","path":"/Algorithm/6366.dijkstra.html","title":"6366. 在网格图中访问一个格子的最少时间（dijkstra在矩阵上的运用）","lang":"zh-CN","frontmatter":{"title":"6366. 在网格图中访问一个格子的最少时间（dijkstra在矩阵上的运用）","icon":"calculator","description":"题目 https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/description/ 思路 首先，这是一个最短路问题 直接用朴素记忆化搜索或者bfs无法实现“反复横跳”这一功能（只有有两个点以上可以走，就可以走到任意一个有最小时间限制的点） 所以更换思维，用图论的方式思考 每个点到上下左右有一条特殊的边，边权值为max(1,(grid[xx][yy]−dist[x][y])/2∗2+1)max( 1 , ( grid[ xx ][ yy ] - dist[ x ][ y ] ) / 2 * 2 + 1 )max(1,(grid[xx][yy]−dist[x][y])/2∗2+1)，前者是一步的权值，后者是需要“反复横跳”才能走到的位置 用堆优化dijkstra方法，因为最大的grid元素不超过1e5，所以堆中的元素是有限的，走的步数也是有限的 当新的最短路径长度小于dist中对应点的大小，更新dist，然后入队 教训：最短路问题都可以通过优化建边的技巧来解决┭┮﹏┭┮ 下面方法和题解的思路有一点不同，通过观察下标得到一个重要的结论：走到一个点的步数奇偶性和下标x+y的奇偶性相同 其实都是一个道理，展现出来的面不同","head":[["meta",{"property":"og:url","content":"https://cfddd.github.io/Algorithm/6366.dijkstra.html"}],["meta",{"property":"og:site_name","content":"俄罗斯刺沙蓬"}],["meta",{"property":"og:title","content":"6366. 在网格图中访问一个格子的最少时间（dijkstra在矩阵上的运用）"}],["meta",{"property":"og:description","content":"题目 https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/description/ 思路 首先，这是一个最短路问题 直接用朴素记忆化搜索或者bfs无法实现“反复横跳”这一功能（只有有两个点以上可以走，就可以走到任意一个有最小时间限制的点） 所以更换思维，用图论的方式思考 每个点到上下左右有一条特殊的边，边权值为max(1,(grid[xx][yy]−dist[x][y])/2∗2+1)max( 1 , ( grid[ xx ][ yy ] - dist[ x ][ y ] ) / 2 * 2 + 1 )max(1,(grid[xx][yy]−dist[x][y])/2∗2+1)，前者是一步的权值，后者是需要“反复横跳”才能走到的位置 用堆优化dijkstra方法，因为最大的grid元素不超过1e5，所以堆中的元素是有限的，走的步数也是有限的 当新的最短路径长度小于dist中对应点的大小，更新dist，然后入队 教训：最短路问题都可以通过优化建边的技巧来解决┭┮﹏┭┮ 下面方法和题解的思路有一点不同，通过观察下标得到一个重要的结论：走到一个点的步数奇偶性和下标x+y的奇偶性相同 其实都是一个道理，展现出来的面不同"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-07-03T12:00:26.000Z"}],["meta",{"property":"article:author","content":"俄罗斯刺沙蓬"}],["meta",{"property":"article:modified_time","content":"2023-07-03T12:00:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"6366. 在网格图中访问一个格子的最少时间（dijkstra在矩阵上的运用）\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-07-03T12:00:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"俄罗斯刺沙蓬\\",\\"url\\":\\"https://cfddd.github.io/\\"}]}"]]},"headers":[{"level":2,"title":"题目","slug":"题目","link":"#题目","children":[]},{"level":2,"title":"思路","slug":"思路","link":"#思路","children":[]},{"level":2,"title":"代码","slug":"代码","link":"#代码","children":[]}],"git":{"createdTime":1688385626000,"updatedTime":1688385626000,"contributors":[{"name":"cfd","email":"2909047212@qq.com","commits":1}]},"readingTime":{"minutes":1.63,"words":490},"filePathRelative":"Algorithm/6366.dijkstra.md","localizedDate":"2023年7月3日","excerpt":"<h2> 题目</h2>\\n<ul>\\n<li><a href=\\"https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/description/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/description/</a></li>\\n</ul>\\n<h2> 思路</h2>\\n<ul>\\n<li>首先，这是一个最短路问题</li>\\n<li>直接用朴素记忆化搜索或者bfs无法实现“反复横跳”这一功能（只有有两个点以上可以走，就可以走到任意一个有最小时间限制的点）</li>\\n<li>所以更换思维，用图论的方式思考\\n<ul>\\n<li>每个点到上下左右有一条特殊的边，边权值为<span class=\\"katex\\"><span class=\\"katex-mathml\\"><math xmlns=\\"http://www.w3.org/1998/Math/MathML\\"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy=\\"false\\">(</mo><mn>1</mn><mo separator=\\"true\\">,</mo><mo stretchy=\\"false\\">(</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo stretchy=\\"false\\">[</mo><mi>x</mi><mi>x</mi><mo stretchy=\\"false\\">]</mo><mo stretchy=\\"false\\">[</mo><mi>y</mi><mi>y</mi><mo stretchy=\\"false\\">]</mo><mo>−</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy=\\"false\\">[</mo><mi>x</mi><mo stretchy=\\"false\\">]</mo><mo stretchy=\\"false\\">[</mo><mi>y</mi><mo stretchy=\\"false\\">]</mo><mo stretchy=\\"false\\">)</mo><mi mathvariant=\\"normal\\">/</mi><mn>2</mn><mo>∗</mo><mn>2</mn><mo>+</mo><mn>1</mn><mo stretchy=\\"false\\">)</mo></mrow><annotation encoding=\\"application/x-tex\\">max( 1 , ( grid[ xx ][ yy ] - dist[ x ][ y ] ) / 2 * 2 + 1 )</annotation></semantics></math></span><span class=\\"katex-html\\" aria-hidden=\\"true\\"><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\">ma</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mopen\\">(</span><span class=\\"mord\\">1</span><span class=\\"mpunct\\">,</span><span class=\\"mspace\\" style=\\"margin-right:0.1667em;\\"></span><span class=\\"mopen\\">(</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">g</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.02778em;\\">r</span><span class=\\"mord mathnormal\\">i</span><span class=\\"mord mathnormal\\">d</span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\">xx</span><span class=\\"mclose\\">]</span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">yy</span><span class=\\"mclose\\">]</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">−</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord mathnormal\\">d</span><span class=\\"mord mathnormal\\">i</span><span class=\\"mord mathnormal\\">s</span><span class=\\"mord mathnormal\\">t</span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\">x</span><span class=\\"mclose\\">]</span><span class=\\"mopen\\">[</span><span class=\\"mord mathnormal\\" style=\\"margin-right:0.03588em;\\">y</span><span class=\\"mclose\\">])</span><span class=\\"mord\\">/2</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">∗</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:0.7278em;vertical-align:-0.0833em;\\"></span><span class=\\"mord\\">2</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span><span class=\\"mbin\\">+</span><span class=\\"mspace\\" style=\\"margin-right:0.2222em;\\"></span></span><span class=\\"base\\"><span class=\\"strut\\" style=\\"height:1em;vertical-align:-0.25em;\\"></span><span class=\\"mord\\">1</span><span class=\\"mclose\\">)</span></span></span></span>，前者是一步的权值，后者是需要“反复横跳”才能走到的位置</li>\\n<li>用堆优化dijkstra方法，因为最大的grid元素不超过1e5，所以堆中的元素是有限的，走的步数也是有限的</li>\\n<li>当新的最短路径长度小于dist中对应点的大小，更新dist，然后入队</li>\\n</ul>\\n</li>\\n<li>教训：最短路问题都可以通过优化建边的技巧来解决┭┮﹏┭┮</li>\\n<li>下面方法和题解的思路有一点不同，通过观察下标得到一个<strong>重要的结论</strong>：走到一个点的步数奇偶性和下标x+y的奇偶性相同</li>\\n<li>其实都是一个道理，展现出来的面不同</li>\\n</ul>","autoDesc":true}');export{s as data};
